"""Defining the AlgorithmNodeTreeManager class."""


from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

from valanga import BranchKey

from anemone import trees
from anemone.indices.index_manager import (
    NodeExplorationIndexManager,
)
from anemone.indices.index_manager.node_exploration_manager import (
    update_all_indices,
)
from anemone.node_evaluation.node_direct_evaluation import (
    EvaluationQueries,
    NodeDirectEvaluator,
)
from anemone.node_factory.algorithm_node_factory import AlgorithmNodeFactory
from anemone.nodes.algorithm_node.algorithm_node import (
    AlgorithmNode,
)
from anemone.updates.algorithm_node_updater import AlgorithmNodeUpdater
from anemone.updates.updates_file import (
    UpdateInstructionsFromOneNode,
    UpdateInstructionsTowardsMultipleNodes,
    UpdateInstructionsTowardsOneParentNode,
)

from .tree_expander import TreeExpansion, TreeExpansions, record_tree_expansion
from .tree_manager import TreeManager

if TYPE_CHECKING:
    from anemone import node_selector as node_sel


@dataclass
class AlgorithmNodeTreeManager[NodeT: AlgorithmNode[Any] = AlgorithmNode[Any]]:
    """Manage an algorithm tree by opening nodes, evaluating new leaves, and updating indices.

    This class wraps :class:`TreeManager` to add AlgorithmNode-specific behavior such as
    evaluation queries, value updates, and exploration index updates.
    """

    tree_manager: TreeManager[NodeT]
    algorithm_tree_node_factory: AlgorithmNodeFactory

    algorithm_node_updater: AlgorithmNodeUpdater
    evaluation_queries: EvaluationQueries
    node_evaluator: NodeDirectEvaluator | None
    index_manager: NodeExplorationIndexManager

    def open_tree_expansion_from_branch(
        self,
        tree: trees.Tree[NodeT],
        parent_node: NodeT,
        branch: BranchKey,
    ) -> TreeExpansion[NodeT]:
        """Open a child node for a specific branch and register it for evaluation.

        Args:
            tree: The tree to expand.
            parent_node: The node to expand.
            branch: The branch key to open from the parent node.

        Returns:
            The resulting tree expansion.

        """
        tree_expansion: TreeExpansion[NodeT]
        tree_expansion = self.tree_manager.open_tree_expansion_from_branch(
            tree=tree, parent_node=parent_node, branch=branch
        )

        parent_node.tree_evaluation.branches_not_over.append(
            branch
        )  # default action checks for over event are performed later

        return tree_expansion

    def open_instructions(
        self,
        tree: trees.Tree[NodeT],
        opening_instructions: "node_sel.OpeningInstructions[NodeT]",
    ) -> TreeExpansions[NodeT]:
        """Apply multiple opening instructions and evaluate any created child nodes.

        Args:
            tree: The tree to expand.
            opening_instructions: The opening instructions to apply.

        Returns:
            The expansions that were performed.

        """
        # place to store the tree expansion logs generated by the openings
        tree_expansions: TreeExpansions[NodeT] = TreeExpansions()

        opening_instruction: node_sel.OpeningInstruction[NodeT]
        tree_expansion: TreeExpansion[NodeT]
        for opening_instruction in opening_instructions.values():
            # open
            assert isinstance(opening_instruction.node_to_open, AlgorithmNode)
            tree_expansion = self.open_tree_expansion_from_branch(
                tree=tree,
                parent_node=opening_instruction.node_to_open,
                branch=opening_instruction.branch,
            )

            record_tree_expansion(
                tree=tree,
                tree_expansions=tree_expansions,
                tree_expansion=tree_expansion,
            )

        assert self.node_evaluator is not None
        for tree_expansion in tree_expansions.expansions_with_node_creation:
            # TODO: give the tree expansion to the function directly
            assert isinstance(tree_expansion.child_node, AlgorithmNode)
            self.node_evaluator.add_evaluation_query(
                node=tree_expansion.child_node,
                evaluation_queries=self.evaluation_queries,
            )

        self.node_evaluator.evaluate_all_queried_nodes(
            evaluation_queries=self.evaluation_queries
        )

        return tree_expansions

    def update_indices(self, tree: trees.Tree[NodeT]) -> None:
        """Updates the indices of the nodes in the given tree.

        Args:
            tree: The tree whose indices need to be updated.

        Returns:
            None

        """
        update_all_indices(index_manager=self.index_manager, tree=tree)

    def update_backward(self, tree_expansions: TreeExpansions[NodeT]) -> None:
        """Update algorithm nodes by propagating updates from recent expansions.

        Args:
            tree_expansions: The expansions that triggered the updates.

        Returns:
            None

        """
        update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[NodeT]
        update_instructions_batch = (
            self.algorithm_node_updater.generate_update_instructions(
                tree_expansions=tree_expansions
            )
        )

        while update_instructions_batch:
            node_to_update: NodeT
            update_instructions: UpdateInstructionsTowardsOneParentNode
            node_to_update, update_instructions = update_instructions_batch.pop_item()
            extra_update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[
                NodeT
            ]
            extra_update_instructions_batch = self.update_node(
                node_to_update=node_to_update, update_instructions=update_instructions
            )
            # merge
            while extra_update_instructions_batch.one_node_instructions:
                parent_node_to_update: NodeT
                update: UpdateInstructionsTowardsOneParentNode
                parent_node_to_update, update = (
                    extra_update_instructions_batch.pop_item()
                )
                update_instructions_batch.add_updates_towards_one_parent_node(
                    parent_node=parent_node_to_update, update_from_child_node=update
                )

    def update_node(
        self,
        node_to_update: NodeT,
        update_instructions: UpdateInstructionsTowardsOneParentNode,
    ) -> UpdateInstructionsTowardsMultipleNodes[NodeT]:
        """Update a node using the provided update instructions.

        Args:
            node_to_update: The node to be updated.
            update_instructions: The instructions for updating the node.

        Returns:
            A batch of update instructions for the parent nodes of the updated node.

        """
        # UPDATES
        new_update_instructions: UpdateInstructionsFromOneNode = (
            self.algorithm_node_updater.perform_updates(
                node_to_update=node_to_update, update_instructions=update_instructions
            )
        )

        update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[NodeT]
        update_instructions_batch = UpdateInstructionsTowardsMultipleNodes()
        parent_node: NodeT
        branch_from_parent: BranchKey
        for parent_node, branch_from_parent in node_to_update.parent_nodes.items():
            # there was a test for emptiness here of new updates instructions remove this comment if no bug appear
            assert parent_node not in update_instructions_batch.one_node_instructions
            update_instructions_batch.add_update_from_one_child_node(
                update_from_child_node=new_update_instructions,
                parent_node=parent_node,
                branch_from_parent=branch_from_parent,
            )

        return update_instructions_batch

    def print_some_stats(self, tree: trees.Tree[NodeT]) -> None:
        """Prints statistics about the given tree.

        Args:
            tree: The tree to print statistics for.

        Returns:
            None

        """
        self.tree_manager.print_some_stats(tree=tree)

    def print_best_line(self, tree: trees.Tree[NodeT]) -> None:
        """Print the best branch line based on the current tree evaluation.

        Args:
            tree: The tree containing branches and their evaluations.

        """
        tree.root_node.tree_evaluation.print_best_line()
