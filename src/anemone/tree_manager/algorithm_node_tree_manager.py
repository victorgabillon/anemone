"""
Defining the AlgorithmNodeTreeManager class
"""

import typing
from dataclasses import dataclass
from typing import Any

from valanga import BranchKey

import anemone.trees as trees
from anemone.indices.index_manager import (
    NodeExplorationIndexManager,
)
from anemone.indices.index_manager.node_exploration_manager import (
    update_all_indices,
)
from anemone.node_evaluation.node_direct_evaluation import (
    EvaluationQueries,
    NodeDirectEvaluator,
)
from anemone.node_factory.algorithm_node_factory import AlgorithmNodeFactory
from anemone.nodes.algorithm_node.algorithm_node import (
    AlgorithmNode,
)
from anemone.updates.algorithm_node_updater import AlgorithmNodeUpdater
from anemone.updates.updates_file import (
    UpdateInstructionsFromOneNode,
    UpdateInstructionsTowardsMultipleNodes,
    UpdateInstructionsTowardsOneParentNode,
)

from .tree_expander import TreeExpansion, TreeExpansions
from .tree_manager import TreeManager

# todo should we use a discount? and discounted per round reward?
# todo maybe convenient to seperate this object into openner updater and dsiplayer
# todo have the reward with a discount
# DISCOUNT = 1/.99999
if typing.TYPE_CHECKING:
    import anemone.node_selector as node_sel
    from anemone.basics import TreeDepth


@dataclass
class AlgorithmNodeTreeManager[TNode: AlgorithmNode[Any] = AlgorithmNode[Any]]:
    """
    This class that and manages a tree by opening new nodes and updating the values and indexes on the nodes.
    It wraps around the Tree Manager class as it has a tree_manager as member and adds functionality as this handles
    trees with nodes that are of the class AlgorithmNode (managing the value for instance)
    """

    tree_manager: TreeManager[TNode]
    algorithm_tree_node_factory: AlgorithmNodeFactory

    algorithm_node_updater: AlgorithmNodeUpdater
    evaluation_queries: EvaluationQueries
    node_evaluator: NodeDirectEvaluator | None
    index_manager: NodeExplorationIndexManager

    def open_tree_expansion_from_branch(
        self,
        tree: trees.Tree[TNode],
        parent_node: TNode,
        branch: BranchKey,
    ) -> TreeExpansion[TNode]:
        """

        Args:
            tree: the tree to open
            parent_node: the node to open
            move: to move to open with

        Returns: the tree expansions

        """

        tree_expansion: TreeExpansion[TNode]
        tree_expansion = self.tree_manager.open_tree_expansion_from_branch(
            tree=tree, parent_node=parent_node, branch=branch
        )

        parent_node.tree_evaluation.branches_not_over.append(
            branch
        )  # default action checks for over event are performed later

        return tree_expansion

    def open_instructions(
        self,
        tree: trees.Tree[TNode],
        opening_instructions: "node_sel.OpeningInstructions[TNode]",
    ) -> TreeExpansions[TNode]:
        """

        Args:
            tree: the tree object to open
            opening_instructions: the opening instructions

        Returns: the expansions that have been performed

        """

        # place to store the tree expansion logs generated by the openings
        tree_expansions: TreeExpansions[TNode] = TreeExpansions()

        opening_instruction: node_sel.OpeningInstruction[TNode]
        tree_expansion: TreeExpansion[TNode]
        for opening_instruction in opening_instructions.values():
            # open
            assert isinstance(opening_instruction.node_to_open, AlgorithmNode)
            tree_expansion = self.open_tree_expansion_from_branch(
                tree=tree,
                parent_node=opening_instruction.node_to_open,
                branch=opening_instruction.branch,
            )

            print("opened", tree_expansion)

            if tree_expansion.creation_child_node:
                tree.nodes_count += 1
                tree.descendants.add_descendant(
                    tree_expansion.child_node
                )  # add it to the list of descendants

            # concatenate the tree expansions
            tree_expansions.add(tree_expansion=tree_expansion)

        assert self.node_evaluator is not None
        for tree_expansion in tree_expansions.expansions_with_node_creation:
            # TODO give the tree expansion to the function directly
            assert isinstance(tree_expansion.child_node, AlgorithmNode)
            self.node_evaluator.add_evaluation_query(
                node=tree_expansion.child_node,
                evaluation_queries=self.evaluation_queries,
            )

        self.node_evaluator.evaluate_all_queried_nodes(
            evaluation_queries=self.evaluation_queries
        )

        return tree_expansions

    def update_indices(self, tree: trees.Tree[TNode]) -> None:
        """
        Updates the indices of the nodes in the given tree.

        Args:
            tree (ValueTree): The tree whose indices need to be updated.

        Returns:
            None
        """
        update_all_indices(index_manager=self.index_manager, tree=tree)

    def update_backward(self, tree_expansions: TreeExpansions[TNode]) -> None:
        """
        Updates the algorithm node tree in a backward manner based on the given tree expansions.

        Args:
            tree_expansions (TreeExpansions): The tree expansions used to update the algorithm node tree.

        Returns:
            None
        """
        update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[TNode]
        update_instructions_batch = (
            self.algorithm_node_updater.generate_update_instructions(
                tree_expansions=tree_expansions
            )
        )

        while update_instructions_batch:
            node_to_update: TNode
            update_instructions: UpdateInstructionsTowardsOneParentNode
            node_to_update, update_instructions = update_instructions_batch.pop_item()
            extra_update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[
                TNode
            ]
            extra_update_instructions_batch = self.update_node(
                node_to_update=node_to_update, update_instructions=update_instructions
            )
            # merge
            while extra_update_instructions_batch.one_node_instructions:
                parent_node_to_update: TNode
                update: UpdateInstructionsTowardsOneParentNode
                parent_node_to_update, update = (
                    extra_update_instructions_batch.pop_item()
                )
                update_instructions_batch.add_updates_towards_one_parent_node(
                    parent_node=parent_node_to_update, update_from_child_node=update
                )

    def update_node(
        self,
        node_to_update: TNode,
        update_instructions: UpdateInstructionsTowardsOneParentNode,
    ) -> UpdateInstructionsTowardsMultipleNodes[TNode]:
        """
        Updates the given node with the provided update instructions.

        Args:
            node_to_update (AlgorithmNode): The node to be updated.
            update_instructions (UpdateInstructions): The instructions for updating the node.

        Returns:
            UpdateInstructionsBatch: A batch of update instructions for the parent nodes of the updated node.
        """

        # UPDATES
        new_update_instructions: UpdateInstructionsFromOneNode = (
            self.algorithm_node_updater.perform_updates(
                node_to_update=node_to_update, update_instructions=update_instructions
            )
        )

        update_instructions_batch: UpdateInstructionsTowardsMultipleNodes[TNode]
        update_instructions_batch = UpdateInstructionsTowardsMultipleNodes()
        parent_node: TNode
        branch_from_parent: BranchKey
        for parent_node, branch_from_parent in node_to_update.parent_nodes.items():
            # there was a test for emptiness here of new updates instructions remove this comment if no bug appear
            assert parent_node not in update_instructions_batch.one_node_instructions
            update_instructions_batch.add_update_from_one_child_node(
                update_from_child_node=new_update_instructions,
                parent_node=parent_node,
                branch_from_parent=branch_from_parent,
            )

        return update_instructions_batch

    def print_some_stats(self, tree: trees.Tree[TNode]) -> None:
        """
        Prints statistics about the given tree.

        Args:
            tree (ValueTree): The tree to print statistics for.

        Returns:
            None
        """
        print(
            "Tree stats: move_count",
            tree.move_count,
            " node_count",
            tree.descendants.get_count(),
        )
        sum_ = 0
        tree.descendants.print_stats()
        tree_depth: TreeDepth
        for tree_depth in tree.descendants:
            sum_ += len(tree.descendants[tree_depth])
            print("tree_depth", tree_depth, len(tree.descendants[tree_depth]), sum_)

    def print_best_line(self, tree: trees.Tree[TNode]) -> None:
        """
        Prints the best line of moves based on the tree evaluation of the tree.

        Args:
            tree (ValueTree): The tree containing the moves and their minmax evaluations.
        """
        tree.root_node.tree_evaluation.print_best_line()
